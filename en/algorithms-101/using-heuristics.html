
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Heuristics & approximate solutions | AP CSP (article) | Khan Academy</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  <style>
.paragraph {
  margin: 10px 0px;
}
img {
  max-width: 600px;
}
.perseus-sr-only {
  display: none;
}
li.perseus-radio-option {
  list-style-type: none;
}
  </style>
</head>
<body>
<div class="container container-md">
<h1>Heuristics & approximate solutions | AP CSP (article) | Khan Academy</h1>
<div class="framework-perseus perseus-article bibliotron-article"><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">The hardest problems in computer science are those that run in superpolynomial time, doubling the number of steps required each time the input size increases—or more than doubling! Computers may be able to solve those problems for very small input sizes, but they very soon get to the point where it can take months or years of computing time to solve them.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">Computer scientists use a different approach for solving those hard problems: instead of trying to find the <em>perfect</em> solution, they try to find an <em>approximate</em> solution. A good answer is better than none at all.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">One way to come up with approximate answers to a problem is to use a <strong>heuristic</strong>, a technique that guides an algorithm to find good choices. When an algorithm uses a heuristic, it no longer needs to exhaustively search every possible solution, so it can find approximate solutions more quickly. A heuristic is a shortcut that sacrifices accuracy and completeness.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">To better understand heuristics, let's walk through one of the most famous hard problems in computer science.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h3>Traveling Salesperson Problem</h3></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">The traveling salesperson problem (TSP) asks the following question:</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">"Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?"</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">For example, this diagram shows the shortest tour between 46 German cities:</div></div><div class="paragraph" data-perseus-paragraph-index="4"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="perseus-image-widget"><img alt="46 dots labeled as German cities. A line goes through the dots, going through each of them exactly once. " aria-hidden="true" src="https://cdn.kastatic.org/ka-perseus-images/916c323eb61b2ba1b396ada88874b6068e0bb05c.svg" tabindex="0"/><span class="perseus-sr-only"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">46 dots labeled as German cities. A line goes through the dots, going through each of them exactly once. </div></div></div></span></div></div></div></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph">The TSP problem was originally faced by traveling salesmen, but is actually relevant to many areas: routing data around a network, manufacturing microchips, observing locations with a telescope, and even sequencing DNA. In all those cases, we want a solution that will find an efficient path between multiple locations.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h4>The brute force approach</h4></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">TSP is a combinatorial problem, and that's what makes it so hard. The only way a computer can find the optimal solution is the "brute force approach": try every possible path between cities, measure the distance of each path, and pick the path with the shortest distance.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">The visualization below generates four random cities, computes the possible paths, and highlights an optimal path. Click on the paths to see the possibilities it comes up with, or start over to try it with a new set of cities.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>&lt;!DOCTYPE html&gt;
&lt;!-- 
TSP example for KA AP CS P Curriculum

Code adapted from 
https://github.com/dzhang55/travelling-salesman
--&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Travelling Salesperson Problem Brute-Force Approach (4 Cities)&lt;/title&gt;
  &lt;!-- WonderBlocks styles --&gt;
  &lt;link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet"&gt;
  &lt;style&gt;
  body {
      font-family: "Lato", sans-serif;
  }
  button.primary {
      -webkit-box-pack: center !important;
      -ms-flex-pack: center !important;
      -webkit-box-align: center !important;
      -ms-flex-align: center !important;
      margin: 0px !important;
      position: relative !important;
      display: -webkit-inline-box !important;
      display: -moz-inline-box !important;
      display: -ms-inline-flexbox !important;
      display: -webkit-inline-flex !important;
      display: inline-flex !important;
      -webkit-align-items: center !important;
      align-items: center !important;
      -webkit-justify-content: center !important;
      justify-content: center !important;
      height: 40px !important;
      padding-top: 0px !important;
      padding-bottom: 0px !important;
      padding-left: 16px !important;
      padding-right: 16px !important;
      border: none !important;
      border-radius: 4px !important;
      cursor: pointer !important;
      outline: none !important;
      text-decoration: none !important;
      -moz-box-sizing: border-box !important;
      box-sizing: border-box !important;
      -ms-touch-action: manipulation !important;
      touch-action: manipulation !important;
      background: #1865f2 !important;
      color: #ffffff !important;
      margin-right: 10px !important;
  }
  button.primary:hover {
      box-shadow: 0 0 0 1px #FFF, 0 0 0 3px #1865f2;
  }
  button.primary span {
      -webkit-box-align: center !important;
      -ms-flex-align: center !important;
      -webkit-font-smoothing: antialiased !important;
      -moz-osx-font-smoothing: grayscale !important;
      font-family: Lato, sans-serif !important;
      font-size: 16px !important;
      line-height: 20px !important;
      display: -webkit-box !important;
      display: -moz-box !important;
      display: -ms-flexbox !important;
      display: -webkit-flex !important;
      display: flex !important;
      -webkit-align-items: center !important;
      align-items: center !important;
      font-weight: bold !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      pointer-events: none !important;
  }
  table, table td {
      border: 1px solid #ccc;
      border-collapse: collapse;
  }
  table td {
      text-align: center;
      width: 3%;
  }
  &lt;/style&gt;
  &lt;style&gt;
  body {
    padding: 8px;
  }
  #svg-container {
    background: #D1E0FC;
    border-radius: 10px;
    margin-bottom: 16px;
  }
  #paths-listing {
    width: 250px;
    float: right;
  }
  #paths-listing tr td {
    line-height: 28px;
    text-align: left;
    padding: 5px;
  }
  #paths-listing tr.highlighted {
    background-color: #F0F1F2;
  }
  #new-button {
    clear: both;
  }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;table id="paths-listing"&gt;
      &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Path&lt;/th&gt;&lt;th&gt;Distance&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
      &lt;tbody&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;div id="svg-container"&gt;
  &lt;/div&gt;
  &lt;div style="display:none;"&gt;
    &lt;span id="slider-value"&gt;4 Points&lt;/span&gt;
    &lt;input id="num-points" value="4" max="30" min="1" type="range"&gt;
  &lt;/div&gt;
  &lt;button id="new-button" class="primary" type="button"&gt;&lt;span&gt;Start over&lt;/span&gt;&lt;/button&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script&gt;
/** Visualization globals **/
var width = 250;
var height = 250;
var N = 200;
var transitionDuration = 12000 / N;
var instantDuration = 20;
var currPathDistance = 0;
var lineWidth = 2;
var points;

var point = [];
var path = [];

/** Solver code **/
var TSPSolver = function(points, width, height) {

// store distances from each point to every other point
var generateDistanceMatrix = function (points) {
    var numPoints = points.length;
    var distanceMatrix = new Array(numPoints);
    for (var i = 0; i &lt; numPoints; i++) {
        distanceMatrix[i] = new Array(numPoints);
    }

    for (var i = 0; i &lt; numPoints; i++) {
        for (var j = i; j &lt; numPoints; j++) {
            distanceMatrix[i][j] = Math.sqrt((points[i].x - points[j].x) * (points[i].x
                - points[j].x) + (points[i].y - points[j].y) * (points[i].y - points[j].y));
            distanceMatrix[j][i] = distanceMatrix[i][j];
        }
    }
    return distanceMatrix;
};

var getPathDistance = function (path, distanceMatrix) {
    var d = distanceMatrix[path[0]][path[path.length - 1]];
    for (var i = 1; i &lt; path.length; i++) {
        d += distanceMatrix[path[i - 1]][path[i]];
    }
    return Math.round( d * 1e2 ) / 1e2;
};

var generateRandomPath = function (numPoints) {
    var path = [];
    for (var i = 0; i &lt; numPoints; i++) {
        path[i] = i;
    }
    path = shuffle(path);
    return path;
};

var swap = function (path, i, j) {
    var clone = path.slice(0);
    var temp = clone[i];
    clone[i] = clone[j];
    clone[j] = temp;
    return clone;
};

var shuffle = function (arr) {
    for (var i = arr.length - 1; i &gt; 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return arr;
};


this.height = height;
this.width = width;
this.path = [];
this.pathDistances = [];
this.paths = [];
this.points = points;
this.numPoints = points.length;
this.distanceMatrix = generateDistanceMatrix(this.points);

// tour of points using nearest neighbor heuristic
this.useNearestNeighbors = function() {
    var remaining = generateRandomPath(this.numPoints);
    this.path = [remaining[0]];
    this.paths.push(this.path.slice(0));
    for (var i = 0; i &lt; this.points.length - 1; i++) {
        var nearestDistance = this.height * this.height + this.width * this.width + 1;
        var nearestPoint = null;
        var indexInRemaining = 0;

        // find nearest neighbor
        for (var j = i + 1; j &lt; this.points.length; j++) {
            currentDistance = this.distanceMatrix[this.path[i]][remaining[j]];
            if (currentDistance &lt; nearestDistance) {
                nearestPoint = remaining[j];
                nearestDistance = currentDistance;
                indexInRemaining = j;
            }
        }
        // add to path and swap in remaining so it will not be added again
        remaining = swap(remaining, i + 1, indexInRemaining);
        this.path.push(remaining[i + 1]);
    }
    this.paths = [this.path];
    this.pathDistances.push(getPathDistance(this.path, this.distanceMatrix));

    return {
        paths: this.paths,
        distances: this.pathDistances,
        isClosed: false
    };
};

// tour of points using nearest neighbor heuristic
this.useBruteForce = function() {
    const startPoint = 0;
    var allPaths = this.findAllPaths(startPoint);

    // TODO:Filter out paths with cycles

    // Generate distances for each path
    for (var i = 0; i &lt; allPaths.length; i++) {
        this.pathDistances.push(getPathDistance(allPaths[i], this.distanceMatrix));
    }

    return {
        paths: allPaths,
        distances: this.pathDistances,
        isClosed: false
    }

}

this.findAllPaths = function(startPoint, paths, path) {
    paths = paths || [];
    path = path || [];
    // Clone current path
    var currentPath = path.slice(0);
    // Add startPoint to path
    currentPath.push(startPoint);

    // Find all unvisited points
    var unvisitedPoints = [];
    for (var i = 0; i &lt; this.points.length; i++) {
        if (currentPath.indexOf(i) &lt; 0) {
            unvisitedPoints.push(i);
        }
    }
    // If no unvisited points, save current path as complete
    if (unvisitedPoints.length === 0) {
        paths.push(currentPath);
        return paths;
    }
    // Now recurse through the unvisited points
    for (var i = 0; i &lt; unvisitedPoints.length; i++) {
        this.findAllPaths(unvisitedPoints[i], paths, currentPath);
    }

    return paths;
};


};

/** Visualization code **/

var toLine = function (isClosed) {
    if (isClosed) {
        var interpolation = 'linear-closed';
    } else {
        var interpolation = 'linear';
    }
    return d3.svg.line()
    	.x(function (d) {
    		return points[d].x;
    	})
    	.y(function (d) {
    		return points[d].y;
    	})
    	.interpolate(interpolation);
};

var generatePoints = function () {
    var padding = 8;
    points = [];
    for (var i = 0; i &lt; N; i++) {
        points[i] = {
            key: String.fromCharCode(65 + i),
            x: Math.floor(Math.random() * (width-padding)) + padding/2,
            y: Math.floor(Math.random() * (height-padding)) + padding/2
        };
    }
};

var drawPoints = function () {
    svg.selectAll('circle')
        .remove();
    svg.selectAll('circle')
        .data(points)
        .enter()
        .append('circle')
        .attr('cx', function (d) {
            return 0;
        })
        .attr('cy', function (d) {
            return 0;
        })
        .attr('cx', function (d) {
            return d.x;
        })
        .attr('cy', function (d) {
            return d.y;
        })
        .attr('r', 4);
};

var drawIndices = function () {
    svg.selectAll('text')
        .remove();
    svg.selectAll('text')
        .data(points)
        .enter()
        .append('text')
        .text(function (d, i) {
            return d.key;
        })
        .attr('fill', 'black')
        .attr('font-family', 'sans-serif')
        .attr('font-size', 12)
        .attr('x', function(d) {
            return d.x + 4;
        })
        .attr('y', function(d) {
            return d.y + 4;
        });
};

var appendPath = function (path, isClosed) {
    clearLines(true);

    svg
        .append('path')
        .attr('d', toLine(isClosed)(path))
        .attr('fill', 'none')
        .attr('stroke', '#14BF96')
        .attr('stroke-width', lineWidth);
};

var clearLines = function (removePath) {
    if (removePath) {
        svg.selectAll('path')
            .remove();
    }
    svg.selectAll('line')
        .remove();
    d3.timer.flush();
};


var highlightTableRow = function(pathNum) {
    var tableRows = document.querySelectorAll("#paths-listing tbody tr");
    for (var i = 0; i &lt; tableRows.length; i++) {
        if (i !== pathNum || tableRows[i] !== pathNum) {
            tableRows[i].classList.remove("highlighted");
        } else {
            tableRows[i].classList.add("highlighted");
        }

    }
};

// iterates through iterations or swaps in order to chain transitions
var animate = function (paths, distances, isClosed) {
    // Find shortest distance
    var shortestDistance = distances[0];
    for (var i = 0; i &lt; distances.length; i++) {
        if (distances[i] &lt; shortestDistance) {
            shortestDistance = distances[i];
        }
    }

    var createPathRow = function(path, distance) {

        var highlightPath = function() {
            highlightTableRow(pathRow);
            appendPath(path, isClosed);
            pathRow.classList.add("highlighted");
        };
        var pathRow = document.createElement("tr");
        var pathInfo = document.createElement("td");
        pathInfo.innerHTML = path.map(function(index) {
          return points[index].key;
        }).join(" - ");
        var pathDistance = document.createElement("td");
        pathDistance.innerHTML = distance;
        if (distance === shortestDistance) {
            pathDistance.innerHTML += " 🏆 ";
            highlightPath();
        }
        pathRow.appendChild(pathInfo);
        pathRow.appendChild(pathDistance);

        pathRow.addEventListener("click", function() {
            highlightPath();
        });
        pathRow.addEventListener("mouseover", function() {
            highlightPath();
        });
        return pathRow;
    };

    var pathsTable = document.querySelector("#paths-listing tbody");
    pathsTable.innerHTML = "";
    for (var i = 0; i &lt; paths.length; i++) {
        pathsTable.appendChild(createPathRow(paths[i], distances[i]));
    }
}

var updatePoints = function() {
    N = parseInt(document.getElementById('num-points').value, 10);
    transitionDuration = 12000 / N;
    generatePoints();
    path.length = 0;
    clearLines(true);
    drawPoints();
    drawIndices();
};

var genAndSolve = function() {
    updatePoints();
    var results = new TSPSolver(points, width, height).useBruteForce();
    clearLines(true);
    animate(results.paths, results.distances, true);
};

// Initial code
var svg = d3.select('#svg-container').append('svg')
    .attr('width', width)
    .attr('height', height);

document.getElementById("svg-container").style.width = width + "px";
document.getElementById("svg-container").style.height = height + "px";

document.getElementById('new-button').addEventListener('click', function (e) {
    genAndSolve();
});

genAndSolve();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div></div></div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Do you notice that it always generates <em>two</em> optimal paths? The paths look the same, but they're in reverse order. Technically, those are both optimal solutions, and a salesperson might choose one shortest path instead of the other for non-distance reasons.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">It doesn't take the computer very long to generate the possible paths for 4 cities—less than a tenth of a millisecond on my machine. It's fairly quick even for <a class="_8gcxk83" href="/computer-programming/traveling-salesperson-more-cities/5815209397157888" rel="noopener noreferrer" tabindex="0" target="_blank">5 cities</a>, <a class="_8gcxk83" href="/computer-programming/traveling-salesperson-6-cities/6016092936437760" rel="noopener noreferrer" tabindex="0" target="_blank">6 cities</a>, and <a class="_8gcxk83" href="/computer-programming/traveling-salesperson-7-cities/5937664082149376" rel="noopener noreferrer" tabindex="0" target="_blank">7 cities</a>; you can try those yourself if you trust your computer.  But the run time grows exponentially, so a few milliseconds soon becomes a few seconds. </div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Here's a table of run times for 4 to 11 cities on my machine:</div></div><div class="paragraph" data-perseus-paragraph-index="3"><table class='table'><thead><tr><th scope="col">Cities</th><th scope="col">Paths</th><th scope="col">Milliseconds</th></tr></thead><tbody><tr><td>4</td><td>6</td><td>0.1</td></tr><tr><td>5</td><td>24</td><td>0.3</td></tr><tr><td>6</td><td>120</td><td>0.8</td></tr><tr><td>7</td><td>720</td><td>3</td></tr><tr><td>8</td><td>5,040</td><td>10</td></tr><tr><td>9</td><td>40,320</td><td>50</td></tr><tr><td>10</td><td>362,880</td><td>520</td></tr><tr><td>11</td><td>3,628,800</td><td>5,770</td></tr></tbody></table></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Notice the jump from 520 to 5770 at the end there? That's when I decided to take pity on my poor laptop and not go any higher. </div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">At that rate, the computer would need about <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--1-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup></mrow><annotation encoding="application/x-tex">2^{53}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span><span id="katex-uid--1-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">2, start superscript, 53, end superscript</span></span><span></span></span> milliseconds to compute the paths for the 46 German cities from the earlier diagram. That's about <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--2-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>6</mn><mn>42</mn></msup></mrow><annotation encoding="application/x-tex">6^{42}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span id="katex-uid--2-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">6, start superscript, 42, end superscript</span></span><span></span></span> years, way longer than the universe has even been in existence. Of course, there are computers than are more powerful than my laptop, but even a supercomputer that is 200,000 times more powerful would require <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--3-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>37</mn></msup></mrow><annotation encoding="application/x-tex">3^{37}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></span><span id="katex-uid--3-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">3, start superscript, 37, end superscript</span></span><span></span></span> years. </div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">So how was that path of 46 cities computed above? With a heuristic, of course!</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h4>Developing a heuristic</h4></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">One way to come up with a heuristic is to consider how you yourself would approach the problem. Humans don't like wasting unnecessary effort on solving problems, so we often find shortcuts that get us to a good enough solution.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">The visualization below shows 5 random cities. Propose a shortest path by clicking the cities, starting with the next city to visit from A. When you're done, find out how your path compares to the optimal path.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>&lt;!DOCTYPE html&gt;
&lt;!--
TSP example for KA AP CS P Curriculum

Code adapted from
https://github.com/dzhang55/travelling-salesman
--&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Traveling Salesman (Try yourself)&lt;/title&gt;
  &lt;!-- WonderBlocks styles --&gt;
  &lt;link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet"&gt;
  &lt;style&gt;
  body {
      font-family: "Lato", sans-serif;
      max-width: 375px;
  }
  button.primary {
      -webkit-box-pack: center;
      -ms-flex-pack: center;
      -webkit-box-align: center;
      -ms-flex-align: center;
      margin: 0px;
      position: relative;
      display: -webkit-inline-box;
      display: -moz-inline-box;
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
      -webkit-align-items: center;
      align-items: center;
      -webkit-justify-content: center;
      justify-content: center;
      height: 40px;
      padding-top: 0px;
      padding-bottom: 0px;
      padding-left: 16px;
      padding-right: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      outline: none;
      text-decoration: none;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
      -ms-touch-action: manipulation;
      touch-action: manipulation;
      background: #1865f2;
      color: #ffffff;
      margin-right: 10px;
  }
  button.primary:hover {
      box-shadow: 0 0 0 1px #FFF, 0 0 0 3px #1865f2;
  }
  button.primary span {
      -webkit-box-align: center;
      -ms-flex-align: center;
      -webkit-font-smoothing: antialiased ;
      -moz-osx-font-smoothing: grayscale ;
      font-family: Lato, sans-serif ;
      font-size: 16px ;
      line-height: 20px ;
      display: -webkit-box ;
      display: -moz-box ;
      display: -ms-flexbox ;
      display: -webkit-flex ;
      display: flex;
      -webkit-align-items: center;
      align-items: center;
      font-weight: bold;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
  }

  button.primary[disabled] {
    background:rgba(33,36,44,0.32);
    color: rgba(255,255,255,0.64);
    cursor: default;
  }
  button.primary[disabled]:hover {
      box-shadow: none;
  }

  button.secondary {
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    -webkit-box-align: center;
    -ms-flex-align: center;
    margin: 0px;
    position: relative;
    display: -webkit-inline-box;
    display: -moz-inline-box;
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
    -webkit-align-items: center;
    align-items: center;
    -webkit-justify-content: center;
    justify-content: center;
    height: 40px;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 16px;
    padding-right: 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    outline: none;
    text-decoration: none;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    -ms-touch-action: manipulation;
    touch-action: manipulation;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    background: none;
    color: #1865f2;
    border-color: rgba(33,36,44,0.50);
    border-style: solid;
    border-width: 1px;
    margin-right: 10px;
  }

  button.secondary span {
    -webkit-box-align: center;
    -ms-flex-align: center;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    font-family: Lato, sans-serif;
    font-size: 16px;
    line-height: 20px;
    display: -webkit-box;
    display: -moz-box;
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -webkit-align-items: center;
    align-items: center;
    font-weight: bold;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none;
  }

  button.secondary:hover {
    border-color: #1865f2;
    border-width: 2px;
    padding-left: 15px;
    padding-right: 15px;
  }

  table, table td {
      border: 1px solid #ccc;
      border-collapse: collapse;
  }
  table td {
      text-align: center;
      width: 3%;
  }
  &lt;/style&gt;
  &lt;style&gt;
  body {
    padding: 8px;
  }
  #svg-container {
    background: #D1E0FC;
    border-radius: 10px;
    margin-bottom: 16px;
  }
  #slider-container {
    margin-bottom: 16px;
  }
  #restart-button {
    clear: both;
  }
  #distance-container {
    float:right;
    float: right;
  }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="distance-container" style="display:none;"&gt;
    &lt;p&gt;
    Your path: &lt;br&gt;
    &lt;span id="drawn-distance"&gt;&lt;/span&gt;
    &lt;/p&gt;
    &lt;p&gt;
    Shortest path: &lt;br&gt;
    &lt;span id="short-distance"&gt;&lt;/span&gt;
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div id="svg-container"&gt;
  &lt;/div&gt;

  &lt;button id="restart-button" class="secondary" type="button"&gt;&lt;span&gt;Start over&lt;/span&gt;&lt;/button&gt;

  &lt;button id="compare-button" class="primary" type="button" disabled&gt;&lt;span&gt;Compare path&lt;/span&gt;&lt;/button&gt;

  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script&gt;
/** Visualization globals **/
var width = 250;
var height = 250;
var N = 200;
var transitionDuration = 12000 / N;
var instantDuration = 20;
var currPathDistance = 0;
var lineWidth = 2;
var points;

var point = [];
var path = [];
var drawnPath = [];

/** Solver code **/
var TSPSolver = function(points, width, height) {

// store distances from each point to every other point
var generateDistanceMatrix = function (points) {
    var numPoints = points.length;
    var distanceMatrix = new Array(numPoints);
    for (var i = 0; i &lt; numPoints; i++) {
        distanceMatrix[i] = new Array(numPoints);
    }

    for (var i = 0; i &lt; numPoints; i++) {
        for (var j = i; j &lt; numPoints; j++) {
            distanceMatrix[i][j] = Math.sqrt((points[i].x - points[j].x) * (points[i].x
                - points[j].x) + (points[i].y - points[j].y) * (points[i].y - points[j].y));
            distanceMatrix[j][i] = distanceMatrix[i][j];
        }
    }
    return distanceMatrix;
};

var getPathDistance = function (path, distanceMatrix) {
    var d = distanceMatrix[path[0]][path[path.length - 1]];
    for (var i = 1; i &lt; path.length; i++) {
        d += distanceMatrix[path[i - 1]][path[i]];
    }
    return Math.round( d * 1e2 ) / 1e2;
};

var generateRandomPath = function (numPoints) {
    var path = [];
    for (var i = 0; i &lt; numPoints; i++) {
        path[i] = i;
    }
    path = shuffle(path);
    return path;
};

var swap = function (path, i, j) {
    var clone = path.slice(0);
    var temp = clone[i];
    clone[i] = clone[j];
    clone[j] = temp;
    return clone;
};

var shuffle = function (arr) {
    for (var i = arr.length - 1; i &gt; 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return arr;
};


this.height = height;
this.width = width;
this.path = [];
this.pathDistances = [];
this.paths = [];
this.points = points;
this.numPoints = points.length;
this.distanceMatrix = generateDistanceMatrix(this.points);

// tour of points using nearest neighbor heuristic
this.useNearestNeighbors = function() {
    var remaining = generateRandomPath(this.numPoints);
    this.path = [remaining[0]];
    this.paths.push(this.path.slice(0));
    for (var i = 0; i &lt; this.points.length - 1; i++) {
        var nearestDistance = this.height * this.height + this.width * this.width + 1;
        var nearestPoint = null;
        var indexInRemaining = 0;

        // find nearest neighbor
        for (var j = i + 1; j &lt; this.points.length; j++) {
            currentDistance = this.distanceMatrix[this.path[i]][remaining[j]];
            if (currentDistance &lt; nearestDistance) {
                nearestPoint = remaining[j];
                nearestDistance = currentDistance;
                indexInRemaining = j;
            }
        }
        // add to path and swap in remaining so it will not be added again
        remaining = swap(remaining, i + 1, indexInRemaining);
        this.path.push(remaining[i + 1]);
    }
    this.paths = [this.path];
    this.pathDistances.push(getPathDistance(this.path, this.distanceMatrix));

    return {
        paths: this.paths,
        distances: this.pathDistances,
        isClosed: false
    };
};

// tour of points using nearest neighbor heuristic
this.useBruteForce = function() {
    const startPoint = 0;
    var allPaths = this.findAllPaths(startPoint);

    // TODO:Filter out paths with cycles

    // Generate distances for each path
    for (var i = 0; i &lt; allPaths.length; i++) {
        this.pathDistances.push(getPathDistance(allPaths[i], this.distanceMatrix));
    }

    return {
        paths: allPaths,
        distances: this.pathDistances,
        isClosed: false
    }

}

this.findAllPaths = function(startPoint, paths, path) {
    paths = paths || [];
    path = path || [];
    // Clone current path
    var currentPath = path.slice(0);
    // Add startPoint to path
    currentPath.push(startPoint);

    // Find all unvisited points
    var unvisitedPoints = [];
    for (var i = 0; i &lt; this.points.length; i++) {
        if (currentPath.indexOf(i) &lt; 0) {
            unvisitedPoints.push(i);
        }
    }
    // If no unvisited points, save current path as complete
    if (unvisitedPoints.length === 0) {
        paths.push(currentPath);
        return paths;
    }
    // Now recurse through the unvisited points
    for (var i = 0; i &lt; unvisitedPoints.length; i++) {
        this.findAllPaths(unvisitedPoints[i], paths, currentPath);
    }

    return paths;
};


};

/** Visualization code **/

var toLine = function (isClosed) {
    if (isClosed) {
        var interpolation = 'linear-closed';
    } else {
        var interpolation = 'linear';
    }
    return d3.svg.line()
    	.x(function (d) {
    		return points[d].x;
    	})
    	.y(function (d) {
    		return points[d].y;
    	})
    	.interpolate(interpolation);
};

var generateKey = function(pathNum) {
  var numLetters = 26;
  var letter = String.fromCharCode(65 + pathNum % numLetters);
  var key = letter;
  if (pathNum &gt; numLetters) {
    var numToRepeat = Math.floor(pathNum/numLetters);
    for (var i = 0; i &lt; numToRepeat; i++) {
      key += letter;
    }
  }
  return key;
};

var generatePoints = function () {
    var padding = 12;
    points = [];
    for (var pathNum = 0; pathNum &lt; N; pathNum++) {
        points[pathNum] = {
            key: generateKey(pathNum),
            x: Math.floor(Math.random() * (width-padding)) + padding/2,
            y: Math.floor(Math.random() * (height-padding)) + padding/2
        };
    }
};

// True if it includes every point
var isCompletePath = function() {
  for (var i = 0; i &lt; points.length; i++) {
    if (drawnPath.indexOf(i) === -1) {
      return false;
    }
  }
  return true;
};

var drawPoints = function () {
    svg.selectAll('circle')
        .remove();
    svg.selectAll('circle')
        .data(points)
        .enter()
        .append('circle')
        .on("mouseover", function() {
          d3.select(this).style("cursor", "pointer");
        })
        .on("mouseout", function() {
          d3.select(this).style("cursor", "default");
        })
        .on("click", function(point, pointNum) {
          // Auto-add the first point
          if (!drawnPath.length) {
            drawnPath.push(0);
          }
          // Don't add duplicate points in a row
          if (drawnPath[drawnPath.length - 1] === pointNum) {
            return;
          }
          // Update and draw path
          drawnPath.push(pointNum);
          appendPath(drawnPath, false);
          // Check for completeness
          if (isCompletePath(drawnPath)) {
            // Auto-add the final point
            if (drawnPath[drawnPath.length - 1] !== 0) {
              drawnPath.push(0);
              appendPath(drawnPath, false);
            }
            document.getElementById("compare-button").removeAttribute("disabled");
          }
        })
        .attr('cx', function (d) {
            return 0;
        })
        .attr('cy', function (d) {
            return 0;
        })
        .attr('cx', function (d) {
            return d.x;
        })
        .attr('cy', function (d) {
            return d.y;
        })
        .attr('r', 6);
};

var drawIndices = function () {
    svg.selectAll('text')
        .remove();
    svg.selectAll('text')
        .data(points)
        .enter()
        .append('text')
        .text(function (d, i) {
            return d.key;
        })
        .on("mouseover", function() {
          d3.select(this).style("cursor", "default");
        })
        .attr('fill', 'black')
        .attr('font-family', 'sans-serif')
        .attr('font-size', 12)
        .attr('x', function(d) {
            return d.x + 8;
        })
        .attr('y', function(d) {
            return d.y + 8;
        });
};

var appendPath = function (path, isClosed) {
    clearLines(true);

    svg
        .append('path')
        .attr('d', toLine(isClosed)(path))
        .attr('fill', 'none')
        .attr('stroke', '#B32471')
        .attr('stroke-width', lineWidth);
};

var appendNewPath = function (path, isClosed) {
    svg
        .append('path')
        .attr('d', toLine(isClosed)(path))
        .attr('fill', 'none')
        .attr('stroke', '#14BF96')
        .attr('stroke-width', lineWidth);
};

var clearLines = function (removePath) {
    if (removePath) {
        svg.selectAll('path')
            .remove();
    }
    svg.selectAll('line')
        .remove();
    d3.timer.flush();
};


var highlightTableRow = function(pathNum) {
    var tableRows = document.querySelectorAll("#paths-listing tbody tr");
    for (var i = 0; i &lt; tableRows.length; i++) {
        if (i !== pathNum || tableRows[i] !== pathNum) {
            tableRows[i].classList.remove("highlighted");
        } else {
            tableRows[i].classList.add("highlighted");
        }

    }
};

// iterates through iterations or swaps in order to chain transitions
var animate = function (paths, distances, isClosed) {
    // Find shortest distance
    var shortestDistance = distances[0];
    for (var i = 0; i &lt; distances.length; i++) {
        if (distances[i] &lt; shortestDistance) {
            shortestDistance = distances[i];
        }
    }

    var drawnPathMinus = drawnPath.slice(0, drawnPath.length - 1).join(",");
    var drawnDistance;
    for (var i = 0; i &lt; paths.length; i++) {
      if (paths[i].join(",") === drawnPathMinus) {
        drawnDistance = distances[i];
        document.getElementById("drawn-distance").innerText = drawnDistance;
      }
      if (distances[i] === shortestDistance) {
        document.getElementById("short-distance").innerText = distances[i];
        appendNewPath(paths[i], isClosed);
        if (drawnDistance === shortestDistance) {
          document.getElementById("drawn-distance").innerText = drawnDistance + " 🏆";
        }
      }
    }
}

var updatePoints = function() {
    document.getElementById("compare-button").setAttribute("disabled", "disabled");
    document.getElementById("distance-container").style.display = "none";
    N = 5;
    transitionDuration = 12000 / N;
    generatePoints();
    drawnPath.length = 0;
    path.length = 0;
    clearLines(true);
    drawPoints();
    drawIndices();
};

var comparePath = function() {
    document.getElementById("compare-button").setAttribute("disabled", "disabled");
    document.getElementById("distance-container").style.display = "block";
    var results = new TSPSolver(points, width, height).useBruteForce();
    animate(results.paths, results.distances, true);
}

// Initial code
var svg = d3.select('#svg-container').append('svg')
    .attr('width', width)
    .attr('height', height);

document.getElementById("svg-container").style.width = width + "px";
document.getElementById("svg-container").style.height = height + "px";

document.getElementById("compare-button").addEventListener("click", comparePath);

document.getElementById("restart-button").addEventListener("click", updatePoints);

updatePoints();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></div></div></div><div class="paragraph" data-perseus-paragraph-index="4"><div class="paragraph">How did your path compare to the optimal path? What heuristics did you use to decide the order to visit the cities? Could the computer use that same heuristic?</div></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph">Not all heuristics are equal, but they can all give us ideas for different ways to guide the computer to find a good solution more quickly.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h4>The nearest-neighbor heuristic</h4></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">A common heuristic for TSP is "nearest neighbor": the computer always picks the <em>nearest</em> unvisited city as the next city on the path. </div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Try it out in the visualization below. Now that we're using a heuristic, you can try it out with many more cities than before. Even 46 cities takes just a few milliseconds on my machine.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>&lt;!DOCTYPE html&gt;
&lt;!--
TSP example for KA AP CS P Curriculum

Code adapted from
https://github.com/dzhang55/travelling-salesman
--&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Traveling Salesman Nearest Neighbor&lt;/title&gt;
  &lt;!-- WonderBlocks styles --&gt;
  &lt;link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet"&gt;
  &lt;style&gt;
  body {
      font-family: "Lato", sans-serif;
  }
  button.primary {
      -webkit-box-pack: center !important;
      -ms-flex-pack: center !important;
      -webkit-box-align: center !important;
      -ms-flex-align: center !important;
      margin: 0px !important;
      position: relative !important;
      display: -webkit-inline-box !important;
      display: -moz-inline-box !important;
      display: -ms-inline-flexbox !important;
      display: -webkit-inline-flex !important;
      display: inline-flex !important;
      -webkit-align-items: center !important;
      align-items: center !important;
      -webkit-justify-content: center !important;
      justify-content: center !important;
      height: 40px !important;
      padding-top: 0px !important;
      padding-bottom: 0px !important;
      padding-left: 16px !important;
      padding-right: 16px !important;
      border: none !important;
      border-radius: 4px !important;
      cursor: pointer !important;
      outline: none !important;
      text-decoration: none !important;
      -moz-box-sizing: border-box !important;
      box-sizing: border-box !important;
      -ms-touch-action: manipulation !important;
      touch-action: manipulation !important;
      background: #1865f2 !important;
      color: #ffffff !important;
      margin-right: 10px !important;
  }
  button.primary:hover {
      box-shadow: 0 0 0 1px #FFF, 0 0 0 3px #1865f2;
  }
  button.primary span {
      -webkit-box-align: center !important;
      -ms-flex-align: center !important;
      -webkit-font-smoothing: antialiased !important;
      -moz-osx-font-smoothing: grayscale !important;
      font-family: Lato, sans-serif !important;
      font-size: 16px !important;
      line-height: 20px !important;
      display: -webkit-box !important;
      display: -moz-box !important;
      display: -ms-flexbox !important;
      display: -webkit-flex !important;
      display: flex !important;
      -webkit-align-items: center !important;
      align-items: center !important;
      font-weight: bold !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      pointer-events: none !important;
  }
  table, table td {
      border: 1px solid #ccc;
      border-collapse: collapse;
  }
  table td {
      text-align: center;
      width: 3%;
  }
  &lt;/style&gt;
  &lt;style&gt;
  body {
    padding: 8px;
  }
  #svg-container {
    background: #D1E0FC;
    border-radius: 10px;
    margin-bottom: 16px;
  }
  #slider-container {
    margin-bottom: 16px;
  }
  #paths-listing {
    width: 250px;
    float: right;
  }
  #paths-listing tr td {
    line-height: 28px;
    text-align: left;
    padding: 5px;
  }
  #paths-listing tr.highlighted {
    background-color: #F0F1F2;
  }
  #new-button {
    clear: both;
  }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;table id="paths-listing" style="display:none;"&gt;
      &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Path&lt;/th&gt;&lt;th&gt;Distance&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
      &lt;tbody&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;div id="svg-container"&gt;
  &lt;/div&gt;
  &lt;div id="slider-container"&gt;
    &lt;input id="num-points" value="5" min="3" max="50" type="range" style="width:220px;"&gt;
    &lt;label id="slider-value" for="num-points"&gt;5&lt;/label&gt;
  &lt;/div&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script&gt;
/** Visualization globals **/
var width = 250;
var height = 250;
var N = 200;
var transitionDuration = 12000 / N;
var instantDuration = 20;
var currPathDistance = 0;
var lineWidth = 2;
var points;

var point = [];
var path = [];

/** Solver code **/
var TSPSolver = function(points, width, height) {

// store distances from each point to every other point
var generateDistanceMatrix = function (points) {
    var numPoints = points.length;
    var distanceMatrix = new Array(numPoints);
    for (var i = 0; i &lt; numPoints; i++) {
        distanceMatrix[i] = new Array(numPoints);
    }

    for (var i = 0; i &lt; numPoints; i++) {
        for (var j = i; j &lt; numPoints; j++) {
            distanceMatrix[i][j] = Math.sqrt((points[i].x - points[j].x) * (points[i].x
                - points[j].x) + (points[i].y - points[j].y) * (points[i].y - points[j].y));
            distanceMatrix[j][i] = distanceMatrix[i][j];
        }
    }
    return distanceMatrix;
};

var getPathDistance = function (path, distanceMatrix) {
    var d = distanceMatrix[path[0]][path[path.length - 1]];
    for (var i = 1; i &lt; path.length; i++) {
        d += distanceMatrix[path[i - 1]][path[i]];
    }
    return Math.round( d * 1e2 ) / 1e2;
};

var generateRandomPath = function (numPoints) {
    var path = [];
    for (var i = 0; i &lt; numPoints; i++) {
        path[i] = i;
    }
    path = shuffle(path);
    return path;
};

var swap = function (path, i, j) {
    var clone = path.slice(0);
    var temp = clone[i];
    clone[i] = clone[j];
    clone[j] = temp;
    return clone;
};

var shuffle = function (arr) {
    for (var i = arr.length - 1; i &gt; 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return arr;
};


this.height = height;
this.width = width;
this.path = [];
this.pathDistances = [];
this.paths = [];
this.points = points;
this.numPoints = points.length;
this.distanceMatrix = generateDistanceMatrix(this.points);

// tour of points using nearest neighbor heuristic
this.useNearestNeighbors = function() {
    var remaining = generateRandomPath(this.numPoints);
    this.path = [remaining[0]];
    this.paths.push(this.path.slice(0));
    for (var i = 0; i &lt; this.points.length - 1; i++) {
        var nearestDistance = this.height * this.height + this.width * this.width + 1;
        var nearestPoint = null;
        var indexInRemaining = 0;

        // find nearest neighbor
        for (var j = i + 1; j &lt; this.points.length; j++) {
            currentDistance = this.distanceMatrix[this.path[i]][remaining[j]];
            if (currentDistance &lt; nearestDistance) {
                nearestPoint = remaining[j];
                nearestDistance = currentDistance;
                indexInRemaining = j;
            }
        }
        // add to path and swap in remaining so it will not be added again
        remaining = swap(remaining, i + 1, indexInRemaining);
        this.path.push(remaining[i + 1]);
    }
    this.paths = [this.path];
    this.pathDistances.push(getPathDistance(this.path, this.distanceMatrix));

    return {
        paths: this.paths,
        distances: this.pathDistances,
        isClosed: false
    };
};

// tour of points using nearest neighbor heuristic
this.useBruteForce = function() {
    const startPoint = 0;
    var allPaths = this.findAllPaths(startPoint);

    // TODO:Filter out paths with cycles

    // Generate distances for each path
    for (var i = 0; i &lt; allPaths.length; i++) {
        this.pathDistances.push(getPathDistance(allPaths[i], this.distanceMatrix));
    }

    return {
        paths: allPaths,
        distances: this.pathDistances,
        isClosed: false
    }

}

this.findAllPaths = function(startPoint, paths, path) {
    paths = paths || [];
    path = path || [];
    // Clone current path
    var currentPath = path.slice(0);
    // Add startPoint to path
    currentPath.push(startPoint);

    // Find all unvisited points
    var unvisitedPoints = [];
    for (var i = 0; i &lt; this.points.length; i++) {
        if (currentPath.indexOf(i) &lt; 0) {
            unvisitedPoints.push(i);
        }
    }
    // If no unvisited points, save current path as complete
    if (unvisitedPoints.length === 0) {
        paths.push(currentPath);
        return paths;
    }
    // Now recurse through the unvisited points
    for (var i = 0; i &lt; unvisitedPoints.length; i++) {
        this.findAllPaths(unvisitedPoints[i], paths, currentPath);
    }

    return paths;
};


};

/** Visualization code **/

var toLine = function (isClosed) {
    if (isClosed) {
        var interpolation = 'linear-closed';
    } else {
        var interpolation = 'linear';
    }
    return d3.svg.line()
    	.x(function (d) {
    		return points[d].x;
    	})
    	.y(function (d) {
    		return points[d].y;
    	})
    	.interpolate(interpolation);
};

var generateKey = function(pathNum) {
  var numLetters = 26;
  var letter = String.fromCharCode(65 + pathNum % numLetters);
  var key = letter;
  if (pathNum &gt; numLetters) {
    var numToRepeat = Math.floor(pathNum/numLetters);
    for (var i = 0; i &lt; numToRepeat; i++) {
      key += letter;
    }
  }
  return key;
};

var generatePoints = function () {
    var padding = 8;
    points = [];
    for (var pathNum = 0; pathNum &lt; N; pathNum++) {
        points[pathNum] = {
            key: generateKey(pathNum),
            x: Math.floor(Math.random() * (width-padding)) + padding/2,
            y: Math.floor(Math.random() * (height-padding)) + padding/2
        };
    }
};

var drawPoints = function () {
    svg.selectAll('circle')
        .remove();
    svg.selectAll('circle')
        .data(points)
        .enter()
        .append('circle')
        .attr('cx', function (d) {
            return 0;
        })
        .attr('cy', function (d) {
            return 0;
        })
        .attr('cx', function (d) {
            return d.x;
        })
        .attr('cy', function (d) {
            return d.y;
        })
        .attr('r', 4);
};

var drawIndices = function () {
    svg.selectAll('text')
        .remove();
    svg.selectAll('text')
        .data(points)
        .enter()
        .append('text')
        .text(function (d, i) {
            return d.key;
        })
        .attr('fill', 'black')
        .attr('font-family', 'sans-serif')
        .attr('font-size', 12)
        .attr('x', function(d) {
            return d.x + 4;
        })
        .attr('y', function(d) {
            return d.y + 4;
        });
};

var appendPath = function (path, isClosed) {
    clearLines(true);

    svg
        .append('path')
        .attr('d', toLine(isClosed)(path))
        .attr('fill', 'none')
        .attr('stroke', '#14BF96')
        .attr('stroke-width', lineWidth);
};

var clearLines = function (removePath) {
    if (removePath) {
        svg.selectAll('path')
            .remove();
    }
    svg.selectAll('line')
        .remove();
    d3.timer.flush();
};


var highlightTableRow = function(pathNum) {
    var tableRows = document.querySelectorAll("#paths-listing tbody tr");
    for (var i = 0; i &lt; tableRows.length; i++) {
        if (i !== pathNum || tableRows[i] !== pathNum) {
            tableRows[i].classList.remove("highlighted");
        } else {
            tableRows[i].classList.add("highlighted");
        }

    }
};

// iterates through iterations or swaps in order to chain transitions
var animate = function (paths, distances, isClosed) {
    // Find shortest distance
    var shortestDistance = distances[0];
    for (var i = 0; i &lt; distances.length; i++) {
        if (distances[i] &lt; shortestDistance) {
            shortestDistance = distances[i];
        }
    }

    var createPathRow = function(path, distance) {

        var highlightPath = function() {
            highlightTableRow(pathRow);
            appendPath(path, isClosed);
            pathRow.classList.add("highlighted");
        };
        var pathRow = document.createElement("tr");
        var pathInfo = document.createElement("td");
        pathInfo.innerHTML = path.map(function(index) {
          return points[index].key;
        }).join(" - ");
        var pathDistance = document.createElement("td");
        pathDistance.innerHTML = distance;
        if (distance === shortestDistance) {
            pathDistance.innerHTML += " 🏆 ";
            highlightPath();
        }
        pathRow.appendChild(pathInfo);
        pathRow.appendChild(pathDistance);

        pathRow.addEventListener("click", function() {
            highlightPath();
        });
        pathRow.addEventListener("mouseover", function() {
            highlightPath();
        });
        return pathRow;
    };

    var pathsTable = document.querySelector("#paths-listing tbody");
    pathsTable.innerHTML = "";
    for (var i = 0; i &lt; paths.length; i++) {
        pathsTable.appendChild(createPathRow(paths[i], distances[i]));
    }
}

var updatePoints = function() {
    N = parseInt(document.getElementById('num-points').value, 10);
    transitionDuration = 12000 / N;
    generatePoints();
    path.length = 0;
    clearLines(true);
    drawPoints();
    drawIndices();
};

var genAndSolve = function() {
    updatePoints();
    var results = new TSPSolver(points, width, height).useNearestNeighbors();
    clearLines(true);
    animate(results.paths, results.distances, true);
};

// Initial code
var svg = d3.select('#svg-container').append('svg')
    .attr('width', width)
    .attr('height', height);

document.getElementById("svg-container").style.width = width + "px";
document.getElementById("svg-container").style.height = height + "px";

document.getElementById("num-points").addEventListener("change", function() {
    updatePoints();
    document.getElementById("slider-value").innerHTML = N;
    genAndSolve();
});

genAndSolve();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></div></div></div><div class="paragraph" data-perseus-paragraph-index="4"><div class="paragraph">Impressive, right? Without a heuristic, we might have waited until the heat death of the universe to find the perfect solution. Now, thanks to a simple heuristic, we see results nearly instantly.</div></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph">But, remember, a heuristic only gives an <em>approximate</em> solution. For this particular heuristic, the solution will be, on average, about 25% longer than the shortest possible path. There are even times where the nearest neighbor heuristic will give the <em>worst</em> route.</div></div><div class="paragraph" data-perseus-paragraph-index="6"><div class="paragraph">Computer scientists have come up with dozens of other heuristics for TSP, including "ant colony optimization", a heuristic inspired by the way that ants deposit pheromones along a path. For each heuristic, they analyze how close the heuristic gets to finding the perfect solution, how much time it takes, and how often the worst case happens.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h3>Heuristics everywhere</h3></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">There are many problems besides TSP that benefit from heuristics. </div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Here are a few:</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph"><strong>Knapsack problem</strong>: You have a knapsack and a set of item types, each with a weight and value. How many of each item can you pack so that the total weight doesn't exceed the limit and the total value is maximized? This type of problem shows up in many forms across different industries, like financial advisors selecting investments for a portfolio or factories figuring out the optimal way to cut up raw materials. One heuristic is to sort by value/weight ratio when selecting the next item to pack.</div></div><div class="paragraph" data-perseus-paragraph-index="4"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="perseus-image-widget"><div class="fixed-to-responsive svg-image" style="max-width: 370px; max-height: 197px;"><img alt="A graphic with a knapsack and 4 boxes. The knapsack is labeled as 15 kg. Box 1 is labeled as 12 kg, $4. Box 2 is labeled as 2 kg, $2. Box 3 is labeled as 4 kg, $10. Box 4 is labeled as 1 kg, $1." aria-hidden="true" src="https://cdn.kastatic.org/ka-perseus-images/5db988cc9a101d5edc98bfb0b35ba7d43461e1c5.svg" tabindex="0"/></div><span class="perseus-sr-only"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">A graphic with a knapsack and 4 boxes. The knapsack is labeled as 15 kg. Box 1 is labeled as 12 kg, <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--4-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4.</mn><mi>B</mi><mi>o</mi><mi>x</mi><mn>2</mn><mi>i</mi><mi>s</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>d</mi><mi>a</mi><mi>s</mi><mn>2</mn><mi>k</mi><mi>g</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">4. Box 2 is labeled as 2 kg, </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span></span></span></span></span><span id="katex-uid--4-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">4, point, B, o, x, 2, i, s, l, a, b, e, l, e, d, a, s, 2, k, g, comma</span></span><span></span></span>2. Box 3 is labeled as 4 kg, <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--5-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10.</mn><mi>B</mi><mi>o</mi><mi>x</mi><mn>4</mn><mi>i</mi><mi>s</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>d</mi><mi>a</mi><mi>s</mi><mn>1</mn><mi>k</mi><mi>g</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">10. Box 4 is labeled as 1 kg, </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord">4</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span></span></span></span></span><span id="katex-uid--5-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">10, point, B, o, x, 4, i, s, l, a, b, e, l, e, d, a, s, 1, k, g, comma</span></span><span></span></span>1.</div></div></div></span><div class="perseus-image-caption"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">A simple knapsack problem with a total weight of 15 kg and 4 item types.</div></div></div></div></div></div></div></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph"><strong>Game-playing</strong>: For a computer to beat a human at a game (or at least lose respectably), it must pick the move with the greatest chance of success. To really predict success, the computer needs to calculate the <em>entire</em> game tree from current move to final move, anticipating all the moves the human could make in response. For the simple game of Tic-Tac-Toe, thats <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--6-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>362</mn><mo separator="true">,</mo><mn>880</mn></mrow><annotation encoding="application/x-tex">362,880</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mord">0</span></span></span></span></span><span id="katex-uid--6-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">362, comma, 880</span></span><span></span></span> possible situations, but for a more sophisticated game like Chess, that's <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--7-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>120</mn></msup></mrow><annotation encoding="application/x-tex">10^{120}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span><span id="katex-uid--7-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">10, start superscript, 120, end superscript</span></span><span></span></span> situations! Fortunately, heuristics like "minimax" help prune down the tree of possibilities. </div></div><div class="paragraph" data-perseus-paragraph-index="6"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="perseus-image-widget"><div class="fixed-to-responsive svg-image" style="max-width: 545px; max-height: 363px;"><img alt="A tree diagram with three levels. The first level shows an empty Tic-Tac-Toe board. The second level shows three Tic-Tac-Toe boards, with an X in a different spot in each one. The third level shows 12 Tic-Tac-Toe boards, with an O in a spot in each one as well." aria-hidden="true" src="https://cdn.kastatic.org/ka-perseus-images/7654fe1f2572ecbad13d67d13d601722ab6ab376.svg" tabindex="0"/></div><span class="perseus-sr-only"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">A tree diagram with three levels. The first level shows an empty Tic-Tac-Toe board. The second level shows three Tic-Tac-Toe boards, with an X in a different spot in each one. The third level shows 12 Tic-Tac-Toe boards, with an O in a spot in each one as well.</div></div></div></span><div class="perseus-image-caption"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">A partial game tree for Tic-Tac-Toe.</div></div></div></div></div></div></div></div><div class="paragraph" data-perseus-paragraph-index="7"><div class="paragraph"><strong>Facility location</strong>: Imagine a supermarket chain that has 20 locations in a state and wants to build 5 warehouses to deliver food to the supermarkets. Their goal is to minimize costs and maximize delivery speed. The facility location problem is finding the optimal location for those 5 warehouses. This same problem is faced by web apps that want to distribute their backend servers to respond to user requests quickly. Heuristics like "local search" help narrow down the array of possible locations.</div></div><div class="paragraph" data-perseus-paragraph-index="8"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="perseus-image-widget"><div class="fixed-to-responsive svg-image" style="max-width: 384px; max-height: 249px;"><img alt="A two-part diagram. The first part shows 20 blue dots distributed around a rectangular space. The second part shows 5 pink dots interspersed in those dots, with arrows connecting each pink dot to a blue dot." aria-hidden="true" src="https://cdn.kastatic.org/ka-perseus-images/1e3e29a4b4b513c226e7e13317146b61a3a60ab4.svg" tabindex="0"/></div><span class="perseus-sr-only"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">A two-part diagram. The first part shows 20 blue dots distributed around a rectangular space. The second part shows 5 pink dots interspersed in those dots, with arrows connecting each pink dot to a blue dot.</div></div></div></span><div class="perseus-image-caption"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">20 locations and a possible solution with 5 facilities.</div></div></div></div></div></div></div></div><div class="paragraph" data-perseus-paragraph-index="9"><div class="paragraph">All of these are combinatorial problems, where a computer would need to search an exponentially growing number of combinations to find the optimal answer. Combinatorial problems are quite common in the real world, so both companies and computer scientists alike care deeply about finding heuristics that will give the best approximate solutions.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph perseus-paragraph-centered" data-perseus-paragraph-index="0"><hr/></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">🙋🏽🙋🏻‍♀️🙋🏿‍♂️Do you have any questions about this topic? We'd love to answer—just ask in the questions area below! <div class="perseus-widget-container widget-nohighlight widget-inline"><div class="_167wsvl"><div class="_pupwzyp"><a aria-expanded="false" class="_13sgcdp7 _7n4oib" href="javascript:void(0)" role="button" tabindex="0">[Where is it?]</a></div></div></div></div></div></div></div></div>
</div>
</body>
</html>
