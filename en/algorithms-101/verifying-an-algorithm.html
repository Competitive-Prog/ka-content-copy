
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Verifying an algorithm | AP CSP (article) | Khan Academy</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  <style>
.paragraph {
  margin: 10px 0px;
}
img {
  max-width: 600px;
}
.perseus-sr-only {
  display: none;
}
li.perseus-radio-option {
  list-style-type: none;
}
  </style>
</head>
<body>
<div class="container container-md">
<h1>Verifying an algorithm | AP CSP (article) | Khan Academy</h1>
<div class="framework-perseus perseus-article bibliotron-article"><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">An important aspect of any algorithm is that it is <strong>correct</strong>: it always produces the expected output for the range of inputs and it eventually terminates.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">As it turns out, it's difficult to prove that an algorithm is correct. Programmers often use <strong>empirical analysis</strong> to find faults in an algorithm, but only <strong>formal reasoning</strong> can prove total correctness.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h3>Empirical analysis</h3></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">An "empirical" analysis is one based on actual experimentation and observation of the results. In the world of algorithms, that means the algorithm must actually be translated into a programming language and executed on a computer.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Let's conduct an empirical analysis of an algorithm that finds the maximum value in a list of numbers. </div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">Here's pseudocode that expresses that algorithm:</div></div><div class="paragraph perseus-paragraph-centered" data-perseus-paragraph-index="4"><pre><code>maxNum ‚Üê -1
FOR num IN numbers {
  if (num &gt; maxNum) {
    maxNum ‚Üê num
  }
}</code></pre></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Next, we'll translate that into the JavaScript language, since we can execute that in our interactive editor here on Khan Academy.</div></div><div class="paragraph perseus-paragraph-centered" data-perseus-paragraph-index="1"><pre><code>var maxNum = -1;
for (var i = 0; i &lt; numbers.length; i++) { 
  if (numbers[i] &gt; maxNum) {
    maxNum = numbers[i];
  }
}</code></pre></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Then we need to feed input into the algorithm and observe how it performs. For our first experiment, let's give it an array of 4 numbers, <code>[13, 4, 24, 7]</code> and see if it outputs the max, 24.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>var numbers = [13, 4, 24, 7];
var maxNum = -1;
for (var i = 0; i &lt; numbers.length; i++) { 
  if (numbers[i] &gt; maxNum) {
    maxNum = numbers[i];
  }
}
println(maxNum);
</pre></div></div></div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Hooray, it worked! Can we declare this to be a perfectly correct algorithm and move on with life? I'm afraid it's not quite that easy...</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">It's time for experiment #2. This time, let's make all the numbers in the array negative, <code>[-13, -4, -24, -7]</code>. This time, the maximum value should be -4, the smallest negative number in the list.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>var numbers = [-13, -4, -24, -7];
var maxNum = -1;
for (var i = 0; i &lt; numbers.length; i++) { 
  if (numbers[i] &gt; maxNum) {
    maxNum = numbers[i];
  }
}
println(maxNum);
</pre></div></div></div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Uh-oh, the code outputted -1 instead of -4. That's because the initial value for <code>maxNum</code> is -1, and the loop never finds a value in the list greater than that. Our algorithm definitely does <em>not</em> work correctly for negative numbers.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">At this point, we need to modify our algorithm and conduct empirical analysis on the (hopefully) improved algorithm. Let's try out a version of the algorithm that initializes <code>maxNum</code> to the first number in the list:</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>var numbers = [-13, -4, -24, -7];
var maxNum = numbers[0];
for (var i = 0; i &lt; numbers.length; i++) { 
  if (numbers[i] &gt; maxNum) {
    maxNum = numbers[i];
  }
}
println(maxNum);
</pre></div></div></div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">That works! Or at least, it works on a list of negative numbers. Does it still work on the list of positive numbers? What about a mixed list of positive and negative numbers? What about fractions? Or irrational numbers? There are so many possibilities to test!</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">We can do the testing more easily by wrapping our algorithm in a procedure, and using a testing library to assert that the output from the procedures matches what we expect. On Khan Academy, <code>Program.assertEqual(actual, expected)</code> is a simple testing procedure that displays an error whenever the actual output is not equal to the expected. </div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Here's an empirical analysis on four different lists:</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph"><div class="perseus-widget-container widget-nohighlight widget-block"><div class="_1vdzrqd"><pre>function findMaxVal(numbers) {
    var maxNum = numbers[0];
    for (var i = 0; i &lt; numbers.length; i++) { 
      if (numbers[i] &gt; maxNum) {
        maxNum = numbers[i];
      }
    }
    return maxNum;
}
Program.assertEqual(
    findMaxVal([-13, -4, -24, -7]),
    -4);
Program.assertEqual(
    findMaxVal([13, 4, 24, 7]),
    24);
Program.assertEqual(
    findMaxVal([13, -4, 24, -7]),
    24);
Program.assertEqual(
    findMaxVal([5/2, -2.22, Math.PI, 99]),
    99);
</pre></div></div></div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">No errors there! The new algorithm is looking more correct than the old one. But is it truly correct? We don't actually know that for sure. In fact, we could do many more experiments and <em>still</em> not know.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">Empirical analysis can only be used to prove that an implemented algorithm is <em>not</em> correct, by discovering inputs where the output is unexpected. However, it cannot prove that an algorithm <em>is</em> correct.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><h3>Formal reasoning</h3></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">The only way to prove the correctness of an algorithm over all possible inputs is by reasoning formally or mathematically about it. </div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">One form of reasoning is a "proof by induction", a technique that's also used by mathematicians to prove properties of numerical sequences. </div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">üìù <strong>Exam tip</strong>: The AP CSP exam does <em>not</em> require an understanding of how to prove algorithms by induction. We walk through it here to give you a feel for what formal reasoning might look like, but the AP does not expect students to understand this advanced level of mathematic reasoning.</div></div><div class="paragraph" data-perseus-paragraph-index="4"><div class="paragraph">A metaphor can help with understanding induction. Imagine we have a line of a million dominos that are perfectly spaced out. How do we know that every domino will fall when we tip the first one over? We don't actually have to check each individual domino. We only have to prove that 1) the first domino will fall, and 2) tipping over any given domino will tip the next domino over. With just those two things proved, just like that, a million dominoes will fall over! </div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Now let's apply induction to an algorithm. Here's the pseudocode for an algorithm that computes the factorial of a positive integer:</div></div><div class="paragraph perseus-paragraph-centered" data-perseus-paragraph-index="1"><pre><code>PROCEDURE calcFactorial(n) {
    factorial ‚Üê 1
    i ‚Üê 1
    REPEAT UNTIL (i &gt; n) {
        factorial ‚Üê factorial * i
        i ‚Üê i + 1
    }
    RETURN factorial
}</code></pre></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">The factorial of a number is the product of that number with all the numbers less than it, down to 1. For example, the factorial of <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--1-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></span><span id="katex-uid--1-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">4</span></span><span></span></span>, often written as <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--2-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">4!</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mclose">!</span></span></span></span></span><span id="katex-uid--2-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">4, !</span></span><span></span></span>, is <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--3-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>√ó</mo><mn>3</mn><mo>√ó</mo><mn>2</mn><mo>√ó</mo><mn>1</mn><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">4 \times 3 \times 2 \times 1 = 24</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">√ó</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">√ó</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">√ó</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span></span><span id="katex-uid--3-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">4, times, 3, times, 2, times, 1, equals, 24</span></span><span></span></span>.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">Before we go down the route of proving this algorithm successfully computes <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--4-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span></span><span id="katex-uid--4-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">n, !</span></span><span></span></span>, let's actually try it out for the <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--5-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span><span id="katex-uid--5-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">n</span></span><span></span></span> of <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--6-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></span><span id="katex-uid--6-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">4</span></span><span></span></span>. If the algorithm works, it should return <span style="white-space: nowrap;"><span></span><span><span></span><span aria-describedby="katex-uid--7-described-by-id" aria-hidden="true" style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span></span><span id="katex-uid--7-described-by-id" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px;">24</span></span><span></span></span>.</div></div><div class="paragraph" data-perseus-paragraph-index="4"><ul><li>The variables <code>factorial</code> and <code>i</code> both start off at <code>1</code>.</li><li>Since <code>i</code> (<code>1</code>) is not greater than <code>n</code> (<code>4</code>), we enter the loop.</li><li>Iteration #1: <code>factorial</code> is set to <code>1</code> (from <code>1 * 1</code>) and <code>i</code> increases to <code>2</code>.</li><li>Iteration #2: <code>factorial</code> is set to <code>2</code> (from <code>1 * 2</code>) and <code>i</code> increases to <code>3</code>.</li><li>Iteration #3: <code>factorial</code> is set to <code>6</code> (from <code>2 * 3</code>) and <code>i</code> increases to <code>4</code>.</li><li>Iteration #4: <code>factorial</code> is set to <code>24</code> (from <code>6 * 4</code>) and <code>i</code> increases to <code>5</code>.</li><li>At this point,  <code>i</code> (<code>5</code>) <em>is</em> greater than <code>n</code> (<code>4</code>), so we exit the loop.</li><li>The procedure returns the value of <code>24</code>.</li></ul></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph">Great, we verified that the algorithm computes the correct result for a single integer. </div></div><div class="paragraph" data-perseus-paragraph-index="6"><div class="paragraph">Now let's prove that for <em>all positive integers</em>, the algorithm computes the factorial of the integer. </div></div><div class="paragraph" data-perseus-paragraph-index="7"><div class="paragraph">First we need to prove that the algorithm eventually terminates, as an algorithm can't be considered correct if it goes on forever. In this algorithm, <code>i</code> starts at <code>1</code> and increases by <code>1</code> until it becomes <code>n + 1</code>. Thus, the algorithm always stops after <code>n</code> loop repetitions.</div></div><div class="paragraph" data-perseus-paragraph-index="8"><div class="paragraph">Next, to prove that this algorithm outputs the factorial, we will more specifically prove a "loop invariant", a property of the loop that should always be true. In this algorithm, after going through the loop <code>n</code> times, <code>factorial</code> should equal <code>n!</code> and <code>i</code> should equal <code>n + 1</code>. That was true in our walk-through of <code>factorial(4)</code>, and now we'll attempt to prove that it is generally true for any positive integer.</div></div><div class="paragraph" data-perseus-paragraph-index="9"><div class="paragraph">That requires proving 1) the base case, and 2) the induction hypothesis.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph"><strong>Base case:</strong> This is where we verify that the algorithm holds for the very first number in the range of possible inputs.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">For this algorithm, we are proving it for all positive integers, so the base case is when <code>n</code> is <code>1</code>. According to our loop invariant, after going through the loop <code>1</code> times, <code>factorial</code> should equal <code>1!</code> (<code>1</code>) and <code>i</code> should equal <code>1 + 1</code> (<code>2</code>).</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">We can walk-through our algorithm for <code>calcFactorial(1)</code>, similar to how we did for the number <code>4</code>:</div></div><div class="paragraph" data-perseus-paragraph-index="3"><ul><li>The variables <code>factorial</code> and  <code>i</code> both start off at <code>1</code>.</li><li>Since <code>i</code> (<code>1</code>) is not greater than <code>n</code> (<code>1</code>), the algorithm enters the loop.</li><li>Iteration #1: <code>factorial</code> is set to <code>1</code> (from <code>1 * 1</code>) and <code>i</code> increases to <code>2</code>.</li><li>At this point,  <code>i</code> (<code>2</code>) <em>is</em> greater than <code>n</code> (<code>1</code>), so the algorithm exits the loop.</li></ul></div><div class="paragraph" data-perseus-paragraph-index="4"><div class="paragraph">Our loop invariant holds: <code>factorial</code> stores <code>1</code> and <code>i</code> stores <code>2</code>.</div></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph">With the base case proved, let's move on!</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph"><strong>Induction step:</strong> This is where we show that if it works for any arbitrary number, it also works for the number right after it.</div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">We start with the inductive hypothesis: an assumption that the loop invariant is true for some positive integer <code>k</code>. After going through the loop <code>k</code> times, <code>factorial</code> should equal <code>k!</code> and <code>i</code> should equal <code>k + 1</code>.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">Starting from that assumption, we will prove that the loop invariant is also true for <code>k + 1</code>, the number just after <code>k</code>. After going through the loop <code>k + 1</code> times, <code>factorial</code> should equal <code>(k + 1)!</code> and <code>i</code> should equal <code>(k + 1) + 1</code>.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">To do that, let's walk-through <code>calcFactorial(k + 1)</code>. We can fast-forward through the first <code>k</code> repetitions, thanks to our inductive hypothesis.</div></div><div class="paragraph" data-perseus-paragraph-index="4"><ul><li>After <code>k</code> repetitions, <code>factorial</code> stores <code>k!</code> and <code>i</code> stores <code>k + 1</code>.</li><li>Iteration #<code>k+1</code>: <code>factorial</code> is set to <code>k! * (k + 1)</code> and <code>i</code> increases to <code>k + 2</code>.</li><li>At this point,  <code>i</code> (whose value is <code>k + 2</code>) <em>is</em> greater than <code>n</code> (whose values is <code>k + 1</code>), so the algorithm exits the loop.</li></ul></div><div class="paragraph" data-perseus-paragraph-index="5"><div class="paragraph">Did the loop invariant hold true? Yes, it did! The variable <code>factorial</code> stores <code>k! * (k + 1)</code>, which is equivalent to <code>(k + 1)!</code> and the variable <code>i</code> stores <code>k + 2</code>, equivalent to <code>(k + 1) + 1</code>. </div></div><div class="paragraph" data-perseus-paragraph-index="6"><div class="paragraph">We can confidently state that the loop invariant is true for all positive integers <code>k</code>.  </div></div><div class="paragraph" data-perseus-paragraph-index="7"><div class="paragraph">Since we showed earlier that the loop stops after <code>n</code> repetitions, then <code>calcFactorial(n)</code> always returns <code>n!</code>. Our algorithm is correct, since it both terminates and produces the correct answer when it terminates.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph" data-perseus-paragraph-index="0"><div class="paragraph">Proof by induction is a technique that works well for algorithms that loop over integers, and can prove that an algorithm always produces correct output. Other styles of proofs can verify correctness for other types of algorithms, like proof by contradiction or proof by exhaustion. </div></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">There are definitely drawbacks to this level of formal reasoning: first, most computer programmers lack the mathematical background to verify with proofs, and secondly, the proof is made outside of the code, so the implementation of the algorithm could diverge from the proved version of the algorithm.</div></div><div class="paragraph" data-perseus-paragraph-index="2"><div class="paragraph">The most popular formal technique for writing correct code is to use a programming languages built specifically with provability as a goal. Cloud computing companies like Amazon and Microsoft use verifiable languages for their critical infrastructure, since they can't afford to be brought down by a bug in their algorithms.</div></div><div class="paragraph" data-perseus-paragraph-index="3"><div class="paragraph">Realistically, the majority of software is verified with empirical analysis. That's partially due to the fact that most programmers lack the theoretical background to prove the correctness of algorithms. But it's also due to the ease of empirical analysis and the fact that a well-thought out suite of tests can prove that an algorithm is almost certainly correct-- and that's often good enough.</div></div></div></div><div class="clearfix"><div class="perseus-renderer perseus-renderer-responsive"><div class="paragraph perseus-paragraph-centered" data-perseus-paragraph-index="0"><hr/></div><div class="paragraph" data-perseus-paragraph-index="1"><div class="paragraph">üôãüèΩüôãüèª‚Äç‚ôÄÔ∏èüôãüèø‚Äç‚ôÇÔ∏èDo you have any questions about this topic? We'd love to answer‚Äîjust ask in the questions area below! <div class="perseus-widget-container widget-nohighlight widget-inline"><div class="_167wsvl"><div class="_pupwzyp"><a aria-expanded="false" class="_13sgcdp7 _7n4oib" href="javascript:void(0)" role="button" tabindex="0">[Where is it?]</a></div></div></div></div></div></div></div></div>
</div>
</body>
</html>
